<-# R은 데이터가 어떤 구조(Structure) 또는 형태로 되어 있느냐에
# 따라 벡터(Vector), 행렬(Matrix), 배열(Array), 데이터
# 프레임(Data frame), 요인(Factor), 리스트(List) 등으로 구분됨

# 가장 대표적인 데이터 형태는 벡터(Vector)임
# 벡터는 동일한 데이터 유형으로 이루어진 한 개 이상의 값들로 구성
# 하나의 열(Column)로 되어 있음
# 벡터는 데이터 분석의 가장 기본 단위임

# 하나의 값으로 이루어진 벡터
s1 <- 10 # 수치형
s2 <- "Hello" # 문자형
s3 <- FALSE # 논리형
s4 <- 1 - 3i # 복소수형

# 두개 이상의 값으로 이루어진 벡터
v1 <- c(10, 20, 30) # v1은 3개의 수치형으로 이루어진 벡터
v2 <- c("Kim", "Park", "Yeo") # v2은 3개의 문자형으로 이루어진 벡터
v3 <- c(TRUE, FALSE, FALSE, FALSE) # v3은 4개의 논리형으로 이루어진 벡터

# 벡터들을 하나로 합쳐서 하나의 새로운 벡터를 생성
v1 <- c(1, 2, 3)
v2 <- c(4, 5, 6)
v3 <- c(v1, v2)
v3 # [1] 1 2 3 4 5 6 출력

# 콜론(:): 1씩 증가되거나 1씩 감소되는 규칙이 있는 값으로 이루어진 벡터를 생성할 때 사용
v1 <- 1:5
v2 <- 5:1
v3 <- -3.3:5
v4 <- 5:-3.3
v1 # [1] 1 2 3 4 5 출력
v2 # [1] 5 4 3 2 1 출력
v3 # [1] -3.3 -2.3 -1.3 -0.3  0.7  1.7  2.7  3.7  4.7 출력
v4 # [1]  5  4  3  2  1  0 -1 -2 -3 출력

# seq(): 1 이외의 증가 또는 감소가 되는 규칙 있는 수치형 벡터를 생성함
v1 <- seq(from = 1, to = 5, by = 1)
v2 <- seq(from = 1, to = 5, by = .5)
v3 <- seq(from = 5, to = 1, by = .5) # error 발생 (by 부호 주의)
v3 <- seq(from = 5, to = 1, by = -.5)
v1 # [1] 1 2 3 4 5 출력
v2 # [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 출력
v3 # [1] 5.0 4.5 4.0 3.5 3.0 2.5 2.0 1.5 1.0 출력

# sequence(): 1과 지정한 ‘숫자’ 사이의 정수로 이루어진 수치형 벡터를 생성
v1 <- sequence(10)
v2 <- sequence(5.5)
v3 <- sequence(1)
v4 <- sequence(0) # 벡터를 초기화할 때 사용할 수 있음
v4 <- sequence(-1) # 음수가 지정되었기 때문에 오류 발생
v1 # [1]  1  2  3  4  5  6  7  8  9 10 출력
v2 # [1] 1 2 3 4 5 출력
v3 # [1] 1 출력
v4 # integer(0) 출력

# rep(): 지정된 데이터를 복사해 주는 기능
v1 <- rep("a", times = 5) # “a”라는 문자형 데이터를 5번 복사해서 문자형 벡터인 v1을 생성
v2 <- rep("a", each = 5) # 복사되는 데이터가 한 개인 경우 times와 each라는 argument에는 차이가 없음
v3 <- rep(c("a", "b"), times = 3) #  두 개의 문자형 “a”와 “b”를 가지는 벡터를 복사하는 것
v4 <- rep(c("a", "b"), each = 3) #  두 개의 문자형 “a”와 “b”를 가지는 벡터를 복사하는 것 (결과 다름)
v5 <- rep(c("a", "b"), times = 3, each = 2) #  each가 먼저, 그 다음에 times가 적용됨
v6 <- rep(c("a", "b"), times = c(10, 5) ) #  each가 먼저, 그 다음에 times가 적용됨

v1 # [1] "a" "a" "a" "a" "a"
v2 # [1] "a" "a" "a" "a" "a"
v3 # [1] "a" "b" "a" "b" "a" "b"
v4 # [1] "a" "a" "a" "b" "b" "b"
v5 # [1] "a" "a" "b" "b" "a" "a" "b" "b" "a" "a" "b" "b"
v6 # [1] "a" "a" "a" "a" "a" "a" "a" "a" "a" "a" "b" "b" "b" "b" "b"

# 벡터의 속성
# 벡터가 가지는 하나의 값 = 원소(Element)
# 벡터가 가지는 값의 데이터 유형을 알아보기 위해 mode(), is.numeric(), is.character(), is.logical(), is.complex() 함수를 사용
v1 <- c(27, 35, 47, 41)

mode(v1) # 데이터 유형을 알려줌 (numeric)
is.numeric(v1) # True 반환
length(v1) # 원소의 갯수 출력 (4)
names(v1) # NULL (지금은 원소의 이름이 없어 NULL)
names(v1) = c("Kim", "Lee", "Park", "Choi") # 원소의 이름 부여
names(v1) # [1] "Kim"  "Lee"  "Park" "Choi"

# 벡터의 인덱싱
weight <- c(54, 81, 65, 49, 72)
weight[1] # 54
weight[2] # 81
weight[c(1, 2, 3)] # [1] 54 81 65
weight[2:4] # [1] 81 65 49
weight[-c(1, 4, 5)] # [1] 81 65


# 벡터의 연산
# 벡터의 연산의 특징은 연산 후 결과도 벡터로 나온다

# 벡터의 길이가 동일한 경우
v1 <- 1:3
v2 <- 4:6
v1 + v2 # [1] 5 7 9
# v1 – v2 # Error: unexpected '\\' in "v1 \"
v1 * v2 # [1]  4 10 18
v1 / v2 # [1] 0.25 0.40 0.50
v1 ** v2 # [1]   1  32 729

# 벡터의 데이터의 갯수가 동일하지 않을 경우 (*recycling)
v1 <- 1:3 # 3개
v2 <- 1:6 # 6개
v1 + v2 # [1] 2 4 6 5 7 9
# 비어있는 수의 개수 만큼 리사이클링 규칙이 적용
v1 <- 1:3
v2 <- 1:10
v1 + v2 # [1]  2  4  6  5  7  9  8 10 12 11
# v1과 v2 벡터 간에 연산, 경고 메시지 발생(warning message)
# ※ v1의 데이터 개수와 v2의 데이터 개수 간에 배수가 존재하지 않기 때문임(3과 10)
